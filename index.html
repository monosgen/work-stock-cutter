<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Work Stock Cutter</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111111">

<style>
:root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
body { margin:0; background:#0b0b0c; color:#f3f3f4; }
header { padding:14px; border-bottom:1px solid #222; position:sticky; top:0; background:#0b0b0c; }
h1 { font-size:16px; margin:0 0 8px; font-weight:700; }
nav { display:flex; gap:8px; }
button.tab { flex:1; padding:10px; border-radius:12px; border:1px solid #2a2a2a; background:#121214; color:#f3f3f4; }
button.tab.active { border-color:#6a6a6a; background:#17171a; }
main { padding:14px; max-width:900px; margin:0 auto; }
.card { background:#121214; border:1px solid #222; border-radius:16px; padding:14px; margin:12px 0; }
label { font-size:12px; color:#cfcfd6; display:block; margin:10px 0 6px; }
input, textarea {
  width:100%; padding:10px 12px; border-radius:12px;
  border:1px solid #2a2a2a; background:#0f0f10; color:#f3f3f4;
  box-sizing:border-box;
}
textarea { min-height:110px; resize:vertical; }
.actions { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
.btn { padding:10px 12px; border-radius:12px; border:1px solid #2a2a2a; background:#17171a; color:#f3f3f4; cursor:pointer; }
.btn.primary { border-color:#6a6a6a; }
.muted { font-size:12px; color:#b8b8c0; }
.pill { display:inline-block; padding:4px 8px; border:1px solid #2a2a2a; border-radius:999px; font-size:12px; }
pre { background:#0f0f10; border:1px solid #2a2a2a; padding:12px; border-radius:14px; white-space:pre-wrap; word-break:break-word; }
</style>
</head>

<body>
<header>
  <h1>Work Stock Cutter</h1>
  <nav>
    <button class="tab active" data-tab="calc">Calculate</button>
    <button class="tab" data-tab="stock">Stock</button>
  </nav>
</header>

<main>

<section id="calc">
  <div class="muted" style="text-align:center">Version: v6.9</div>

  <div class="card">
    <label>Stock Length (mm)</label>
    <input id="stockLen" type="number" value="11900" min="1">

    <label>Profile</label>
    <input id="profile" value="100/4">

    <label>Stock trim (mm) ‚Äî applies to SAVED stock/offcuts only</label>
    <input id="stockTrim" type="number" value="10" min="0" max="200">

    <label>Base cut from NEW (mm) ‚Äî optional (example: 2900 for 5900 bars)</label>
    <input id="baseCut" type="number" value="0" min="0">

    <label>Lengths (mm)</label>
    <textarea id="lengths" placeholder="4094 4094 4094 4094 4308 4308 4308 4308 4458"></textarea>

    <div class="actions">
      <button class="btn primary" id="calcBtn">Make cut plan</button>
      <button class="btn" id="clearBtn">Clear</button>
    </div>

    <div class="muted" style="margin-top:8px">
      Rule: stock first. If Base cut is set, planner may cut NEW bars into base pieces (like 2900+2900 from 5900) and top-up with stock.
      Stock/offcuts lose ‚ÄúStock trim‚Äù from the crude end. Weld = max 2 bars.
    </div>
  </div>

  <div class="card">
    <div class="pill">Result</div>
    <pre id="result">‚Äî</pre>
  </div>
</section>

<section id="stock" style="display:none">
  <div class="card">
    <label>Profile</label>
    <input id="stockProfile" value="100/4">

    <label>Add stock length (mm)</label>
    <input id="stockAdd" type="number" placeholder="e.g. 1500">

    <div class="actions">
      <button class="btn primary" id="addStock">Add stock</button>
      <button class="btn" id="addFull">Add full bar (Stock Length)</button>
      <button class="btn" id="clearStock">Clear profile stock</button>
    </div>

    <div class="muted" style="margin-top:8px">
      Save leftovers/offcuts here. Trim is applied during planning.
    </div>
  </div>

  <div class="card">
    <div class="pill">Stock (this profile)</div>
    <pre id="stockView">‚Äî</pre>
  </div>
</section>

</main>

<script>
// PWA
if ("serviceWorker" in navigator) navigator.serviceWorker.register("./service-worker.js");

// Storage
const LS = "wsc_stock_v6_9";
function loadAll(){ try { return JSON.parse(localStorage.getItem(LS)||"{}"); } catch { return {}; } }
function saveAll(v){ localStorage.setItem(LS, JSON.stringify(v)); }
function getStock(p){ return (loadAll()[p] || []).slice(); }
function setStock(p,a){ const s=loadAll(); s[p]=a; saveAll(s); }

function parseLengths(t){
  return (t||"")
    .replace(/,/g," ")
    .split(/\s+/)
    .map(x=>x.trim())
    .filter(Boolean)
    .map(Number)
    .filter(n=>Number.isFinite(n) && n>0)
    .map(n=>Math.round(n));
}

function refreshStock(){
  const p = stockProfile.value.trim();
  const a = getStock(p).sort((a,b)=>b-a);
  stockView.textContent = a.length ? a.map(x=>x+" mm").join("\n") : "No stock";
}

/**
 * Planner v6.9
 * Adds BaseCut strategy:
 * - If baseCut>0: for a required length L, try:
 *     baseCut from NEW + (L-baseCut) from ONE saved stock/offcut
 *   This allows your 5900 -> 2900+2900 approach.
 */
function makePlan(stockLen, profile, needs, trim, baseCut){
  // saved stock/offcuts
  const stockBars = getStock(profile).sort((a,b)=>b-a);

  // bins include STOCK and NEW bars (NEW bars opened on demand)
  const bins = stockBars.map((len, idx) => ({
    kind: "STOCK",
    base: len,
    rem: Math.max(0, len - trim),
    id: `STOCK-${idx+1}`,
    display: String(len),
    weldLocked: false // only matters for stock used in welds
  }));

  let newCount = 0;
  const newDisplays = []; // all NEW bars created in this plan, in order

  function newBin(){
    newCount++;
    const disp = `${stockLen}#${newCount}`;
    const b = { kind:"NEW", base:stockLen, rem:stockLen, id:`NEW-${newCount}`, display:disp };
    bins.push(b);
    newDisplays.push(disp);
    return b;
  }

  // best-fit (single cut) in any bin
  function bestFitBin(need){
    let best = null;
    for (const b of bins){
      if (b.rem >= need){
        const after = b.rem - need;
        if (!best || after < best.after) best = { b, after };
      }
    }
    return best ? best.b : null;
  }

  // find best stock/offcut to supply "need2" (one bar only), prefer smallest leftover
  function bestStockFor(need2){
    let best = null;
    for (const b of bins){
      if (b.kind !== "STOCK") continue;
      if (b.weldLocked) continue; // "1 stock = 1 weld" rule
      if (b.rem >= need2){
        const after = b.rem - need2;
        if (!best || after < best.after) best = { b, after };
      }
    }
    return best ? best.b : null;
  }

  // take a baseCut segment from NEW bars:
  // - reuse an already-open NEW bar if it has enough remainder
  // - else open a new one
  function takeBaseFromNew(){
    for (const b of bins){
      if (b.kind === "NEW" && b.rem >= baseCut) return b;
    }
    return newBin();
  }

  const results = [];
  let seq = 0;

  // process big first helps a lot
  const work = [...needs].sort((a,b)=>b-a);

  for (const need of work){
    if (need > stockLen){
      return { ok:false, error:`Required ${need} > Stock Length ${stockLen}.` };
    }

    // 1) Fit whole into existing bar
    const fit = bestFitBin(need);
    if (fit){
      fit.rem -= need;
      seq++;
      results.push({
        need, welded:false, seq,
        mainDisplay: (fit.kind === "NEW") ? fit.display : null,
        parts:[{ cut: need, fromDisplay: fit.display }]
      });
      continue;
    }

    // 2) BaseCut strategy (NEW base + stock top-up)
    if (baseCut > 0 && baseCut < stockLen && need > baseCut){
      const need2 = need - baseCut; // what we must take from stock/offcut
      const st = bestStockFor(need2);
      if (st){
        const nb = takeBaseFromNew();
        // allocate
        nb.rem -= baseCut;
        st.rem -= need2;
        st.weldLocked = true;

        seq++;
        results.push({
          need, welded:true, seq,
          mainDisplay: nb.display, // group under the NEW bar
          parts:[
            { cut: baseCut, fromDisplay: nb.display },
            { cut: need2,  fromDisplay: st.display }
          ]
        });
        continue;
      }
    }

    // 3) Fallback: open NEW bar and cut whole (no weld)
    const nb = newBin();
    nb.rem -= need;

    seq++;
    results.push({
      need, welded:false, seq,
      mainDisplay: nb.display,
      parts:[{ cut: need, fromDisplay: nb.display }]
    });
  }

  const totalLeftoverUsable = bins.reduce((s,b)=>s + b.rem, 0);
  return { ok:true, plan:{ results, totalLeftoverUsable, trim, newDisplays } };
}

// Output: STOCK section + headers for ALL created NEW bars (even if only 1 line)
function format(plan){
  const out = [];
  out.push("=== WHAT TO USE ===\n");

  // sort overall: non-weld first, welded last, then seq
  const sorted = [...plan.results].sort((a,b)=>{
    if (a.welded !== b.welded) return a.welded ? 1 : -1;
    return a.seq - b.seq;
  });

  const stockLines = [];
  const byNew = new Map();

  for (const r of sorted){
    if (!r.mainDisplay) stockLines.push(r);
    else {
      if (!byNew.has(r.mainDisplay)) byNew.set(r.mainDisplay, []);
      byNew.get(r.mainDisplay).push(r);
    }
  }

  if (stockLines.length){
    out.push("STOCK / OFFCUTS");
    for (const r of stockLines){
      out.push(`${r.need} = ${r.need} (${r.parts[0].fromDisplay})`);
    }
    out.push("");
  }

  // show every created NEW bar header
  const newKeys = (plan.newDisplays || []).slice().sort((a,b)=>{
    const na = Number((a.split("#")[1]||"0"));
    const nb = Number((b.split("#")[1]||"0"));
    return na - nb;
  });

  for (const key of newKeys){
    out.push(key);
    const lines = (byNew.get(key) || []).slice();

    // inside each NEW group: non-weld first, welded last, then seq
    lines.sort((a,b)=>{
      if (a.welded !== b.welded) return a.welded ? 1 : -1;
      return a.seq - b.seq;
    });

    if (!lines.length){
      out.push("(no cuts)");
      out.push("");
      continue;
    }

    for (const r of lines){
      if (!r.welded){
        out.push(`${r.need} = ${r.need} (${r.parts[0].fromDisplay})`);
      } else {
        // print as: L üî• = base(new) + topup(stock)
        const partsTxt = r.parts.map(p => `${p.cut} (${p.fromDisplay})`).join(" + ");
        out.push(`${r.need} üî• = ${partsTxt}`);
      }
    }
    out.push("");
  }

  out.push(`Leftover saved (usable): ${plan.totalLeftoverUsable} mm`);
  out.push(`Stock trim used: ${plan.trim} mm`);
  return out.join("\n");
}

// UI
const stockLenEl = document.getElementById("stockLen");
const profileEl  = document.getElementById("profile");
const trimEl     = document.getElementById("stockTrim");
const baseCutEl  = document.getElementById("baseCut");
const lengthsEl  = document.getElementById("lengths");
const resultEl   = document.getElementById("result");

const stockProfile = document.getElementById("stockProfile");
const stockAdd     = document.getElementById("stockAdd");
const stockView    = document.getElementById("stockView");

document.getElementById("calcBtn").onclick = () => {
  const stockLen = Math.round(Number(stockLenEl.value));
  const profile = profileEl.value.trim();
  const trim = Math.max(0, Math.round(Number(trimEl.value || 0)));
  const baseCut = Math.max(0, Math.round(Number(baseCutEl.value || 0)));
  const needs = parseLengths(lengthsEl.value);

  if (!profile) { resultEl.textContent = "‚ùå Please enter Profile."; return; }
  if (!(stockLen > 0)) { resultEl.textContent = "‚ùå Stock Length must be > 0."; return; }
  if (!needs.length) { resultEl.textContent = "‚ùå Enter at least one required length."; return; }

  const res = makePlan(stockLen, profile, needs, trim, baseCut);
  if (!res.ok) { resultEl.textContent = "‚ùå " + res.error; return; }
  resultEl.textContent = format(res.plan);
};

document.getElementById("clearBtn").onclick = () => {
  lengthsEl.value = "";
  resultEl.textContent = "‚Äî";
};

document.getElementById("addStock").onclick = () => {
  const p = stockProfile.value.trim();
  const v = Math.round(Number(stockAdd.value));
  if (!p || !(v > 0)) return;
  const a = getStock(p); a.push(v); setStock(p,a);
  stockAdd.value = "";
  refreshStock();
};

document.getElementById("addFull").onclick = () => {
  const p = stockProfile.value.trim();
  const v = Math.round(Number(stockLenEl.value || 11900));
  if (!p || !(v > 0)) return;
  const a = getStock(p); a.push(v); setStock(p,a);
  refreshStock();
};

document.getElementById("clearStock").onclick = () => {
  const p = stockProfile.value.trim();
  if (!p) return;
  setStock(p, []);
  refreshStock();
};

document.querySelectorAll(".tab").forEach(b=>{
  b.onclick = () => {
    document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
    b.classList.add("active");
    document.getElementById("calc").style.display = b.dataset.tab==="calc" ? "" : "none";
    document.getElementById("stock").style.display = b.dataset.tab==="stock" ? "" : "none";
    refreshStock();
  };
});

refreshStock();
</script>

</body>
</html>