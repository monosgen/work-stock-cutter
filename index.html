<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Work Stock Cutter</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111111">

<style>
:root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
body { margin:0; background:#0b0b0c; color:#f3f3f4; }
header { padding:14px; border-bottom:1px solid #222; position:sticky; top:0; background:#0b0b0c; }
h1 { font-size:16px; margin:0 0 8px; font-weight:700; }
nav { display:flex; gap:8px; }
button.tab { flex:1; padding:10px; border-radius:12px; border:1px solid #2a2a2a; background:#121214; color:#f3f3f4; }
button.tab.active { border-color:#6a6a6a; background:#17171a; }
main { padding:14px; max-width:900px; margin:0 auto; }
.card { background:#121214; border:1px solid #222; border-radius:16px; padding:14px; margin:12px 0; }
label { font-size:12px; color:#cfcfd6; display:block; margin:10px 0 6px; }
input, textarea {
  width:100%; padding:10px 12px; border-radius:12px;
  border:1px solid #2a2a2a; background:#0f0f10; color:#f3f3f4;
  box-sizing:border-box;
}
textarea { min-height:110px; resize:vertical; }
.actions { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
.btn { padding:10px 12px; border-radius:12px; border:1px solid #2a2a2a; background:#17171a; color:#f3f3f4; cursor:pointer; }
.btn.primary { border-color:#6a6a6a; }
.muted { font-size:12px; color:#b8b8c0; }
.pill { display:inline-block; padding:4px 8px; border:1px solid #2a2a2a; border-radius:999px; font-size:12px; }
pre { background:#0f0f10; border:1px solid #2a2a2a; padding:12px; border-radius:14px; white-space:pre-wrap; word-break:break-word; }
.groupTitle { font-weight:700; letter-spacing:0.5px; }
</style>
</head>

<body>
<header>
  <h1>Work Stock Cutter</h1>
  <nav>
    <button class="tab active" data-tab="calc">Calculate</button>
    <button class="tab" data-tab="stock">Stock</button>
  </nav>
</header>

<main>

<section id="calc">
  <div class="muted" style="text-align:center">Version: v6.7</div>

  <div class="card">
    <label>Stock Length (mm)</label>
    <input id="stockLen" type="number" value="11900" min="1">

    <label>Profile</label>
    <input id="profile" value="100/4">

    <label>Stock trim (mm) ‚Äî applies to SAVED stock/offcuts only</label>
    <input id="stockTrim" type="number" value="10" min="0" max="200">

    <label>Lengths (mm)</label>
    <textarea id="lengths" placeholder="5000 653 8643 532 4322"></textarea>

    <div class="actions">
      <button class="btn primary" id="calcBtn">Make cut plan</button>
      <button class="btn" id="clearBtn">Clear</button>
    </div>

    <div class="muted" style="margin-top:8px">
      Rule: stock first. If needed, weld using max 2 bars. Stock/offcuts lose ‚ÄúStock trim‚Äù from the crude end.
      NEW full bars show as StockLength#1, #2, ...
    </div>
  </div>

  <div class="card">
    <div class="pill">Result</div>
    <pre id="result">‚Äî</pre>
  </div>
</section>

<section id="stock" style="display:none">
  <div class="card">
    <label>Profile</label>
    <input id="stockProfile" value="100/4">

    <label>Add stock length (mm)</label>
    <input id="stockAdd" type="number" placeholder="e.g. 6582">

    <div class="actions">
      <button class="btn primary" id="addStock">Add stock</button>
      <button class="btn" id="addFull">Add full bar (Stock Length)</button>
      <button class="btn" id="clearStock">Clear profile stock</button>
    </div>

    <div class="muted" style="margin-top:8px">
      Save leftovers/offcuts here. Trim is applied during planning.
    </div>
  </div>

  <div class="card">
    <div class="pill">Stock (this profile)</div>
    <pre id="stockView">‚Äî</pre>
  </div>
</section>

</main>

<script>
// PWA
if ("serviceWorker" in navigator) navigator.serviceWorker.register("./service-worker.js");

// Storage
const LS = "wsc_stock_v6_7";
function loadAll(){ try { return JSON.parse(localStorage.getItem(LS)||"{}"); } catch { return {}; } }
function saveAll(v){ localStorage.setItem(LS, JSON.stringify(v)); }
function getStock(p){ return (loadAll()[p] || []).slice(); }
function setStock(p,a){ const s=loadAll(); s[p]=a; saveAll(s); }

function parseLengths(t){
  return (t||"")
    .replace(/,/g," ")
    .split(/\s+/)
    .map(x=>x.trim())
    .filter(Boolean)
    .map(Number)
    .filter(n=>Number.isFinite(n) && n>0)
    .map(n=>Math.round(n));
}

function refreshStock(){
  const p = stockProfile.value.trim();
  const a = getStock(p).sort((a,b)=>b-a);
  stockView.textContent = a.length ? a.map(x=>x+" mm").join("\n") : "No stock";
}

// Planner
function makePlan(stockLen, profile, needs, trim){
  const stockBars = getStock(profile).sort((a,b)=>b-a);

  const bins = stockBars.map((len, idx) => ({
    kind: "STOCK",
    base: len,
    rem: Math.max(0, len - trim),
    id: `STOCK-${idx+1}`,
    display: String(len) // no # for saved stock
  }));

  let newCount = 0;
  function newBin(){
    newCount++;
    const b = {
      kind:"NEW",
      base: stockLen,
      rem: stockLen,
      id: `NEW-${newCount}`,
      display: `${stockLen}#${newCount}` // # for new bars
    };
    bins.push(b);
    return b;
  }

  const results = [];
  let seq = 0;

  for (const need of needs){
    if (need > stockLen){
      return { ok:false, error:`Required ${need} > Stock Length ${stockLen}.` };
    }

    // Whole fit: best-fit across existing bins first
    let best = null;
    for (const b of bins){
      if (b.rem >= need){
        const after = b.rem - need;
        if (!best || after < best.after) best = { b, after };
      }
    }

    if (best){
      best.b.rem -= need;
      seq++;
      results.push({
        need,
        welded:false,
        seq,
        mainId: best.b.id,
        parts:[{ cut: need, fromId: best.b.id, fromDisplay: best.b.display }]
      });
      continue;
    }

    // Weld: use one partial bin + finish from another (or new)
    let bestSplit = null;

    for (const b1 of bins){
      if (!(b1.rem > 0 && b1.rem < need)) continue;

      const take1 = b1.rem;
      const need2 = need - take1;

      let b2 = null;
      let b2after = Infinity;
      for (const b of bins){
        if (b === b1) continue;
        if (b.rem >= need2){
          const after = b.rem - need2;
          if (after < b2after){ b2after = after; b2 = b; }
        }
      }

      const newAfter = stockLen - need2;
      const chooseNew = (!b2) || (newAfter < b2after);
      const afterWaste = chooseNew ? newAfter : b2after;

      if (!bestSplit || afterWaste < bestSplit.afterWaste){
        bestSplit = { b1, take1, need2, b2, chooseNew, afterWaste };
      }
    }

    if (bestSplit){
      const { b1, take1, need2, b2, chooseNew } = bestSplit;
      const b2real = chooseNew ? newBin() : b2;

      b1.rem = 0;
      b2real.rem -= need2;

      seq++;
      const mainId = (b2real.kind === "NEW") ? b2real.id : b1.id;

      results.push({
        need,
        welded:true,
        seq,
        mainId,
        parts:[
          { cut: take1, fromId: b1.id, fromDisplay: b1.display },
          { cut: need2, fromId: b2real.id, fromDisplay: b2real.display }
        ]
      });
      continue;
    }

    // Otherwise open new bar
    const nb = newBin();
    nb.rem -= need;

    seq++;
    results.push({
      need,
      welded:false,
      seq,
      mainId: nb.id,
      parts:[{ cut: need, fromId: nb.id, fromDisplay: nb.display }]
    });
  }

  const totalLeftoverUsable = bins.reduce((s,b)=>s + b.rem, 0);
  return { ok:true, plan:{ results, totalLeftoverUsable, trim } };
}

// Output with NEW-bar group headers
function format(plan){
  const out = [];
  out.push("=== WHAT TO USE ===\n");

  // sort: non-weld first, welded last, then by seq (keeps natural cut order)
  const sorted = [...plan.results].sort((a,b) => {
    if (a.welded !== b.welded) return a.welded ? 1 : -1;
    return a.seq - b.seq;
  });

  // helper: does this required piece touch a NEW bar? (any part fromDisplay includes '#')
  function usedNewDisplay(r){
    const p = r.parts.find(x => (x.fromDisplay || "").includes("#"));
    return p ? p.fromDisplay : null; // returns like "11900#1"
  }

  // Split results:
  const stockOnly = [];
  const byNew = new Map(); // key: "11900#1" -> array of results

  for (const r of sorted){
    const newDisp = usedNewDisplay(r);
    if (!newDisp){
      stockOnly.push(r);
    } else {
      if (!byNew.has(newDisp)) byNew.set(newDisp, []);
      byNew.get(newDisp).push(r);
    }
  }

  // print stock/offcuts section first (if any)
  if (stockOnly.length){
    out.push("STOCK / OFFCUTS");
    for (const r of stockOnly){
      if (!r.welded){
        out.push(`${r.need} = ${r.need} (${r.parts[0].fromDisplay})`);
      } else {
        const partsTxt = r.parts.map(p => `${p.cut} (${p.fromDisplay})`).join(" + ");
        out.push(`${r.need} üî• = ${partsTxt}`);
      }
    }
    out.push(""); // blank line
  }

  // sort NEW group headers by the # number
  const newKeys = Array.from(byNew.keys()).sort((a,b) => {
    const na = Number((a.split("#")[1]||"0"));
    const nb = Number((b.split("#")[1]||"0"));
    return na - nb;
  });

  for (const key of newKeys){
    out.push(key);
    const arr = byNew.get(key);

    // inside each new-bar group: keep non-weld first, welded last, then seq
    arr.sort((a,b) => {
      if (a.welded !== b.welded) return a.welded ? 1 : -1;
      return a.seq - b.seq;
    });

    for (const r of arr){
      if (!r.welded){
        out.push(`${r.need} = ${r.need} (${r.parts[0].fromDisplay})`);
      } else {
        const partsTxt = r.parts.map(p => `${p.cut} (${p.fromDisplay})`).join(" + ");
        out.push(`${r.need} üî• = ${partsTxt}`);
      }
    }
    out.push(""); // blank line between groups
  }

  out.push(`Leftover saved (usable): ${plan.totalLeftoverUsable} mm`);
  out.push(`Stock trim used: ${plan.trim} mm`);
  return out.join("\n");
}

// UI
const stockLenEl = document.getElementById("stockLen");
const profileEl  = document.getElementById("profile");
const trimEl     = document.getElementById("stockTrim");
const lengthsEl  = document.getElementById("lengths");
const resultEl   = document.getElementById("result");

const stockProfile = document.getElementById("stockProfile");
const stockAdd     = document.getElementById("stockAdd");
const stockView    = document.getElementById("stockView");

document.getElementById("calcBtn").onclick = () => {
  const stockLen = Math.round(Number(stockLenEl.value));
  const profile = profileEl.value.trim();
  const trim = Math.max(0, Math.round(Number(trimEl.value || 0)));
  const needs = parseLengths(lengthsEl.value);

  if (!profile) { resultEl.textContent = "‚ùå Please enter Profile."; return; }
  if (!(stockLen > 0)) { resultEl.textContent = "‚ùå Stock Length must be > 0."; return; }
  if (!needs.length) { resultEl.textContent = "‚ùå Enter at least one required length."; return; }

  const res = makePlan(stockLen, profile, needs, trim);
  if (!res.ok) { resultEl.textContent = "‚ùå " + res.error; return; }
  resultEl.textContent = format(res.plan);
};

document.getElementById("clearBtn").onclick = () => {
  lengthsEl.value = "";
  resultEl.textContent = "‚Äî";
};

document.getElementById("addStock").onclick = () => {
  const p = stockProfile.value.trim();
  const v = Math.round(Number(stockAdd.value));
  if (!p || !(v > 0)) return;
  const a = getStock(p); a.push(v); setStock(p,a);
  stockAdd.value = "";
  refreshStock();
};

document.getElementById("addFull").onclick = () => {
  const p = stockProfile.value.trim();
  const v = Math.round(Number(stockLenEl.value || 11900));
  if (!p || !(v > 0)) return;
  const a = getStock(p); a.push(v); setStock(p,a);
  refreshStock();
};

document.getElementById("clearStock").onclick = () => {
  const p = stockProfile.value.trim();
  if (!p) return;
  setStock(p, []);
  refreshStock();
};

document.querySelectorAll(".tab").forEach(b=>{
  b.onclick = () => {
    document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
    b.classList.add("active");
    document.getElementById("calc").style.display = b.dataset.tab==="calc" ? "" : "none";
    document.getElementById("stock").style.display = b.dataset.tab==="stock" ? "" : "none";
    refreshStock();
  };
});

refreshStock();
</script>

</body>
</html>