<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Work Stock Cutter</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111111">

<style>
:root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
body { margin:0; background:#0b0b0c; color:#f3f3f4; }
header { padding:14px; border-bottom:1px solid #222; position:sticky; top:0; background:#0b0b0c; }
h1 { font-size:16px; margin:0 0 8px; font-weight:700; }
nav { display:flex; gap:8px; }
button.tab { flex:1; padding:10px; border-radius:12px; border:1px solid #2a2a2a; background:#121214; color:#f3f3f4; }
button.tab.active { border-color:#6a6a6a; background:#17171a; }
main { padding:14px; max-width:900px; margin:0 auto; }
.card { background:#121214; border:1px solid #222; border-radius:16px; padding:14px; margin:12px 0; }
label { font-size:12px; color:#cfcfd6; display:block; margin:10px 0 6px; }
input, textarea {
  width:100%; padding:10px 12px; border-radius:12px;
  border:1px solid #2a2a2a; background:#0f0f10; color:#f3f3f4;
  box-sizing:border-box;
}
textarea { min-height:110px; resize:vertical; }
.actions { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
.btn { padding:10px 12px; border-radius:12px; border:1px solid #2a2a2a; background:#17171a; color:#f3f3f4; cursor:pointer; }
.btn.primary { border-color:#6a6a6a; }
.muted { font-size:12px; color:#b8b8c0; }
.pill { display:inline-block; padding:4px 8px; border:1px solid #2a2a2a; border-radius:999px; font-size:12px; }
pre { background:#0f0f10; border:1px solid #2a2a2a; padding:12px; border-radius:14px; white-space:pre-wrap; word-break:break-word; }
</style>
</head>

<body>
<header>
  <h1>Work Stock Cutter</h1>
  <nav>
    <button class="tab active" data-tab="calc">Calculate</button>
    <button class="tab" data-tab="stock">Stock</button>
  </nav>
</header>

<main>

<section id="calc">
  <div class="muted" style="text-align:center">Version: v6.5</div>

  <div class="card">
    <label>Stock Length (mm)</label>
    <input id="stockLen" type="number" value="11900" min="1">

    <label>Profile</label>
    <input id="profile" value="100/4">

    <label>Stock trim (mm) ‚Äî applies to SAVED stock/offcuts only</label>
    <input id="stockTrim" type="number" value="10" min="0" max="200">

    <label>Lengths (mm)</label>
    <textarea id="lengths" placeholder="4510 8451 1412 5452 5615"></textarea>

    <div class="actions">
      <button class="btn primary" id="calcBtn">Make cut plan</button>
      <button class="btn" id="clearBtn">Clear</button>
    </div>

    <div class="muted" style="margin-top:8px">
      Rule: stock first. If needed, weld using max 2 bars. Stock/offcuts lose ‚ÄúStock trim‚Äù from the crude end.
    </div>
  </div>

  <div class="card">
    <div class="pill">Result</div>
    <pre id="result">‚Äî</pre>
  </div>
</section>

<section id="stock" style="display:none">
  <div class="card">
    <label>Profile</label>
    <input id="stockProfile" value="100/4">

    <label>Add stock length (mm)</label>
    <input id="stockAdd" type="number" placeholder="e.g. 4814">

    <div class="actions">
      <button class="btn primary" id="addStock">Add stock</button>
      <button class="btn" id="addFull">Add full bar (Stock Length)</button>
      <button class="btn" id="clearStock">Clear profile stock</button>
    </div>

    <div class="muted" style="margin-top:8px">
      Save leftovers/offcuts here. Trim is applied during planning.
    </div>
  </div>

  <div class="card">
    <div class="pill">Stock (this profile)</div>
    <pre id="stockView">‚Äî</pre>
  </div>
</section>

</main>

<script>
// PWA
if ("serviceWorker" in navigator) navigator.serviceWorker.register("./service-worker.js");

// Storage
const LS = "wsc_stock_v6_5";
function loadAll(){ try { return JSON.parse(localStorage.getItem(LS)||"{}"); } catch { return {}; } }
function saveAll(v){ localStorage.setItem(LS, JSON.stringify(v)); }
function getStock(p){ return (loadAll()[p] || []).slice(); }
function setStock(p,a){ const s=loadAll(); s[p]=a; saveAll(s); }

function parseLengths(t){
  return (t||"")
    .replace(/,/g," ")
    .split(/\s+/)
    .map(x=>x.trim())
    .filter(Boolean)
    .map(Number)
    .filter(n=>Number.isFinite(n) && n>0)
    .map(n=>Math.round(n));
}

function refreshStock(){
  const p = stockProfile.value.trim();
  const a = getStock(p).sort((a,b)=>b-a);
  stockView.textContent = a.length ? a.map(x=>x+" mm").join("\n") : "No stock";
}

// Planner (keeps internal ids for ordering, prints only lengths)
function makePlan(stockLen, profile, needs, trim){
  const stockBars = getStock(profile).sort((a,b)=>b-a);

  // bins store internal id + printLen (no # in printLen)
  const bins = stockBars.map((len, idx) => ({
    kind: "STOCK",
    base: len,
    rem: Math.max(0, len - trim),
    id: `STOCK-${idx+1}`,     // internal
    printLen: len             // shown in ( )
  }));

  let newCount = 0;
  function newBin(){
    newCount++;
    const b = {
      kind:"NEW",
      base: stockLen,
      rem: stockLen,
      id: `NEW-${newCount}`,  // internal
      printLen: stockLen      // shown in ( )
    };
    bins.push(b);
    return b;
  }

  const results = [];
  let seq = 0;

  for (const need of needs){
    if (need > stockLen){
      return { ok:false, error:`Required ${need} > Stock Length ${stockLen}.` };
    }

    // Whole fit: best-fit across ALL existing bins first (stock+already-open new)
    let best = null;
    for (const b of bins){
      if (b.rem >= need){
        const after = b.rem - need;
        if (!best || after < best.after) best = { b, after };
      }
    }

    if (best){
      best.b.rem -= need;
      seq++;
      results.push({
        need,
        welded:false,
        seq,
        mainId: best.b.id,
        parts:[{ cut: need, fromId: best.b.id, fromLen: best.b.printLen }]
      });
      continue;
    }

    // Weld: use up one partially-usable bin then finish from another bin or a new bar
    let bestSplit = null;

    for (const b1 of bins){
      if (!(b1.rem > 0 && b1.rem < need)) continue;

      const take1 = b1.rem;
      const need2 = need - take1;

      // best-fit b2 (existing)
      let b2 = null;
      let b2after = Infinity;
      for (const b of bins){
        if (b === b1) continue;
        if (b.rem >= need2){
          const after = b.rem - need2;
          if (after < b2after){ b2after = after; b2 = b; }
        }
      }

      // compare to opening a new bar
      const newAfter = stockLen - need2;
      const chooseNew = (!b2) || (newAfter < b2after);
      const afterWaste = chooseNew ? newAfter : b2after;

      if (!bestSplit || afterWaste < bestSplit.afterWaste){
        bestSplit = { b1, take1, need2, b2, chooseNew, afterWaste };
      }
    }

    if (bestSplit){
      const { b1, take1, need2, b2, chooseNew } = bestSplit;
      const b2real = chooseNew ? newBin() : b2;

      b1.rem = 0;
      b2real.rem -= need2;

      seq++;
      // mainId: prefer the bar you keep on the machine (NEW bar if involved, else b1)
      const mainId = (b2real.kind === "NEW") ? b2real.id : b1.id;

      results.push({
        need,
        welded:true,
        seq,
        mainId,
        parts:[
          { cut: take1, fromId: b1.id, fromLen: b1.printLen },
          { cut: need2, fromId: b2real.id, fromLen: b2real.printLen }
        ]
      });
      continue;
    }

    // Otherwise open one new bar and cut from it
    const nb = newBin();
    nb.rem -= need;

    seq++;
    results.push({
      need,
      welded:false,
      seq,
      mainId: nb.id,
      parts:[{ cut: need, fromId: nb.id, fromLen: nb.printLen }]
    });
  }

  const totalLeftoverUsable = bins.reduce((s,b)=>s + b.rem, 0);
  return { ok:true, plan:{ results, totalLeftoverUsable, trim } };
}

// Output formatting:
// - non-weld first
// - welded last
// - group by mainId (keeps same 11900 together)
// - then by seq
function format(plan){
  const out = [];
  out.push("=== WHAT TO USE ===\n");

  const lines = [...plan.results].sort((a,b) => {
    if (a.welded !== b.welded) return a.welded ? 1 : -1;     // welded last
    if (a.mainId !== b.mainId) return a.mainId.localeCompare(b.mainId); // group by bar
    return a.seq - b.seq;
  });

  for (const r of lines){
    if (!r.welded){
      out.push(`${r.need} = ${r.need} (${r.parts[0].fromLen})`);
    } else {
      const partsTxt = r.parts.map(p => `${p.cut} (${p.fromLen})`).join(" + ");
      out.push(`${r.need} üî• = ${partsTxt}`);
    }
  }

  out.push(`\nLeftover saved (usable): ${plan.totalLeftoverUsable} mm`);
  out.push(`Stock trim used: ${plan.trim} mm`);
  return out.join("\n");
}

// UI
const stockLenEl = document.getElementById("stockLen");
const profileEl  = document.getElementById("profile");
const trimEl     = document.getElementById("stockTrim");
const lengthsEl  = document.getElementById("lengths");
const resultEl   = document.getElementById("result");

const stockProfile = document.getElementById("stockProfile");
const stockAdd     = document.getElementById("stockAdd");
const stockView    = document.getElementById("stockView");

document.getElementById("calcBtn").onclick = () => {
  const stockLen = Math.round(Number(stockLenEl.value));
  const profile = profileEl.value.trim();
  const trim = Math.max(0, Math.round(Number(trimEl.value || 0)));
  const needs = parseLengths(lengthsEl.value);

  if (!profile) { resultEl.textContent = "‚ùå Please enter Profile."; return; }
  if (!(stockLen > 0)) { resultEl.textContent = "‚ùå Stock Length must be > 0."; return; }
  if (!needs.length) { resultEl.textContent = "‚ùå Enter at least one required length."; return; }

  const res = makePlan(stockLen, profile, needs, trim);
  if (!res.ok) { resultEl.textContent = "‚ùå " + res.error; return; }
  resultEl.textContent = format(res.plan);
};

document.getElementById("clearBtn").onclick = () => {
  lengthsEl.value = "";
  resultEl.textContent = "‚Äî";
};

document.getElementById("addStock").onclick = () => {
  const p = stockProfile.value.trim();
  const v = Math.round(Number(stockAdd.value));
  if (!p || !(v > 0)) return;
  const a = getStock(p); a.push(v); setStock(p,a);
  stockAdd.value = "";
  refreshStock();
};

document.getElementById("addFull").onclick = () => {
  const p = stockProfile.value.trim();
  const v = Math.round(Number(stockLenEl.value || 11900));
  if (!p || !(v > 0)) return;
  const a = getStock(p); a.push(v); setStock(p,a);
  refreshStock();
};

document.getElementById("clearStock").onclick = () => {
  const p = stockProfile.value.trim();
  if (!p) return;
  setStock(p, []);
  refreshStock();
};

document.querySelectorAll(".tab").forEach(b=>{
  b.onclick = () => {
    document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
    b.classList.add("active");
    document.getElementById("calc").style.display = b.dataset.tab==="calc" ? "" : "none";
    document.getElementById("stock").style.display = b.dataset.tab==="stock" ? "" : "none";
    refreshStock();
  };
});

refreshStock();
</script>

</body>
</html>
