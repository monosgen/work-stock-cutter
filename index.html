<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Work Stock Cutter</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111111">

<style>
:root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
body { margin:0; background:#0b0b0c; color:#f3f3f4; }
header { padding:14px; border-bottom:1px solid #222; position:sticky; top:0; background:#0b0b0c; }
h1 { font-size:16px; margin:0 0 8px; font-weight:700; }
nav { display:flex; gap:8px; }
button.tab { flex:1; padding:10px; border-radius:12px; border:1px solid #2a2a2a; background:#121214; color:#f3f3f4; }
button.tab.active { border-color:#6a6a6a; background:#17171a; }
main { padding:14px; max-width:900px; margin:0 auto; }
.card { background:#121214; border:1px solid #222; border-radius:16px; padding:14px; margin:12px 0; }
label { font-size:12px; color:#cfcfd6; display:block; margin:10px 0 6px; }
input, textarea {
  width:100%; padding:10px 12px; border-radius:12px;
  border:1px solid #2a2a2a; background:#0f0f10; color:#f3f3f4;
  box-sizing:border-box;
}
textarea { min-height:110px; resize:vertical; }
.actions { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
.btn { padding:10px 12px; border-radius:12px; border:1px solid #2a2a2a; background:#17171a; color:#f3f3f4; cursor:pointer; }
.btn.primary { border-color:#6a6a6a; }
.muted { font-size:12px; color:#b8b8c0; }
.pill { display:inline-block; padding:4px 8px; border:1px solid #2a2a2a; border-radius:999px; font-size:12px; }
pre { background:#0f0f10; border:1px solid #2a2a2a; padding:12px; border-radius:14px; white-space:pre-wrap; word-break:break-word; }
</style>
</head>

<body>
<header>
  <h1>Work Stock Cutter</h1>
  <nav>
    <button class="tab active" data-tab="calc">Calculate</button>
    <button class="tab" data-tab="stock">Stock</button>
  </nav>
</header>

<main>

<section id="calc">
  <div class="muted" style="text-align:center">Version: v6.8</div>

  <div class="card">
    <label>Stock Length (mm)</label>
    <input id="stockLen" type="number" value="11900" min="1">

    <label>Profile</label>
    <input id="profile" value="100/4">

    <label>Stock trim (mm) ‚Äî applies to SAVED stock/offcuts only</label>
    <input id="stockTrim" type="number" value="10" min="0" max="200">

    <label>Lengths (mm)</label>
    <textarea id="lengths" placeholder="5455 4233 4334 4345 4345"></textarea>

    <div class="actions">
      <button class="btn primary" id="calcBtn">Make cut plan</button>
      <button class="btn" id="clearBtn">Clear</button>
    </div>

    <div class="muted" style="margin-top:8px">
      Rule: stock first. If needed, weld using max 2 bars.
      Stock/offcuts lose ‚ÄúStock trim‚Äù from the crude end.
      NEW full bars show as StockLength#1, #2, ...
    </div>
  </div>

  <div class="card">
    <div class="pill">Result</div>
    <pre id="result">‚Äî</pre>
  </div>
</section>

<section id="stock" style="display:none">
  <div class="card">
    <label>Profile</label>
    <input id="stockProfile" value="100/4">

    <label>Add stock length (mm)</label>
    <input id="stockAdd" type="number" placeholder="e.g. 5528">

    <div class="actions">
      <button class="btn primary" id="addStock">Add stock</button>
      <button class="btn" id="addFull">Add full bar (Stock Length)</button>
      <button class="btn" id="clearStock">Clear profile stock</button>
    </div>

    <div class="muted" style="margin-top:8px">
      Save leftovers/offcuts here. Trim is applied during planning.
    </div>
  </div>

  <div class="card">
    <div class="pill">Stock (this profile)</div>
    <pre id="stockView">‚Äî</pre>
  </div>
</section>

</main>

<script>
// PWA
if ("serviceWorker" in navigator) navigator.serviceWorker.register("./service-worker.js");

// Storage
const LS = "wsc_stock_v6_8";
function loadAll(){ try { return JSON.parse(localStorage.getItem(LS)||"{}"); } catch { return {}; } }
function saveAll(v){ localStorage.setItem(LS, JSON.stringify(v)); }
function getStock(p){ return (loadAll()[p] || []).slice(); }
function setStock(p,a){ const s=loadAll(); s[p]=a; saveAll(s); }

function parseLengths(t){
  return (t||"")
    .replace(/,/g," ")
    .split(/\s+/)
    .map(x=>x.trim())
    .filter(Boolean)
    .map(Number)
    .filter(n=>Number.isFinite(n) && n>0)
    .map(n=>Math.round(n));
}

function refreshStock(){
  const p = stockProfile.value.trim();
  const a = getStock(p).sort((a,b)=>b-a);
  stockView.textContent = a.length ? a.map(x=>x+" mm").join("\n") : "No stock";
}

/**
 * makePlan rules:
 * - Try fit in existing bars first (stock + any already-open NEW bars)
 * - If not possible, weld using:
 *    A) STOCK+STOCK (only if both are SAVED stock and neither has been used in a weld before)
 *    B) STOCK + already-open NEW (never open a NEW bar just to weld)
 * - Otherwise, open a NEW bar and cut from it (no weld)
 */
function makePlan(stockLen, profile, needs, trim){
  const stockBars = getStock(profile).sort((a,b)=>b-a);

  // bins = stock/offcut pieces
  const bins = stockBars.map((len, idx) => ({
    kind: "STOCK",
    base: len,
    rem: Math.max(0, len - trim),
    id: `STOCK-${idx+1}`,
    display: String(len),
    weldLocked: false // true after this stock is used in a weld
  }));

  // list of NEW bars that got opened
  let newCount = 0;
  const newDisplays = []; // ["11900#1","11900#2",...]

  function newBin(){
    newCount++;
    const disp = `${stockLen}#${newCount}`;
    const b = {
      kind:"NEW",
      base: stockLen,
      rem: stockLen,
      id: `NEW-${newCount}`,
      display: disp
    };
    bins.push(b);
    newDisplays.push(disp);
    return b;
  }

  // best-fit for a single cut into any bin
  function bestFitBin(need){
    let best = null;
    for (const b of bins){
      if (b.rem >= need){
        const after = b.rem - need;
        if (!best || after < best.after) best = { b, after };
      }
    }
    return best ? best.b : null;
  }

  // best-fit but ONLY among already-open NEW bars
  function bestFitOpenNew(need){
    let best = null;
    for (const b of bins){
      if (b.kind !== "NEW") continue;
      if (b.rem >= need){
        const after = b.rem - need;
        if (!best || after < best.after) best = { b, after };
      }
    }
    return best ? best.b : null;
  }

  const results = [];
  let seq = 0;

  // process larger first for better packing
  const work = [...needs].sort((a,b)=>b-a);

  for (const need of work){
    if (need > stockLen){
      return { ok:false, error:`Required ${need} > Stock Length ${stockLen}.` };
    }

    // 1) try fit whole in any existing bar
    const fit = bestFitBin(need);
    if (fit){
      fit.rem -= need;
      seq++;
      results.push({
        need,
        welded:false,
        seq,
        mainDisplay: (fit.kind === "NEW") ? fit.display : null,
        parts:[{ cut: need, fromDisplay: fit.display }]
      });
      continue;
    }

    // 2) try weld STOCK + STOCK (no opening NEW)
    // choose the largest STOCK remainder first (to avoid slicing one stock into many welds)
    let bestWeldSS = null;
    const stockList = bins
      .filter(b => b.kind==="STOCK" && !b.weldLocked && b.rem > 0)
      .sort((a,b)=>b.rem - a.rem);

    for (let i=0; i<stockList.length; i++){
      const b1 = stockList[i];
      if (b1.rem >= need) continue; // would have fit, but it didn't; still skip
      const take1 = b1.rem;
      const need2 = need - take1;

      // find b2 that can finish
      let b2best = null;
      let afterBest = Infinity;
      for (let j=0; j<stockList.length; j++){
        if (j===i) continue;
        const b2 = stockList[j];
        if (b2.rem >= need2){
          const after = b2.rem - need2;
          if (after < afterBest){
            afterBest = after;
            b2best = b2;
          }
        }
      }

      if (b2best){
        bestWeldSS = { b1, b2: b2best, take1, need2, afterBest };
        break; // because b1 are sorted by largest rem: use biggest donor first
      }
    }

    if (bestWeldSS){
      const { b1, b2, take1, need2 } = bestWeldSS;
      b1.rem = 0;
      b2.rem -= need2;
      b1.weldLocked = true;
      b2.weldLocked = true;

      seq++;
      results.push({
        need,
        welded:true,
        seq,
        mainDisplay: null, // stock section
        parts:[
          { cut: take1, fromDisplay: b1.display },
          { cut: need2, fromDisplay: b2.display }
        ]
      });
      continue;
    }

    // 3) try weld STOCK + already-open NEW (NEVER open a NEW bar just to weld)
    // choose largest STOCK remainder first
    let bestWeldSN = null;
    for (const b1 of stockList){
      if (b1.rem <= 0 || b1.rem >= need) continue;
      const take1 = b1.rem;
      const need2 = need - take1;

      const newBar = bestFitOpenNew(need2);
      if (newBar){
        const after = newBar.rem - need2;
        bestWeldSN = { b1, newBar, take1, need2, after };
        break;
      }
    }

    if (bestWeldSN){
      const { b1, newBar, take1, need2 } = bestWeldSN;
      b1.rem = 0;
      b1.weldLocked = true;
      newBar.rem -= need2;

      seq++;
      results.push({
        need,
        welded:true,
        seq,
        // group under the NEW bar we actually need on the machine
        mainDisplay: newBar.display,
        parts:[
          { cut: take1, fromDisplay: b1.display },
          { cut: need2, fromDisplay: newBar.display }
        ]
      });
      continue;
    }

    // 4) otherwise open a NEW bar and cut whole (no weld)
    const nb = newBin();
    nb.rem -= need;

    seq++;
    results.push({
      need,
      welded:false,
      seq,
      mainDisplay: nb.display,
      parts:[{ cut: need, fromDisplay: nb.display }]
    });
  }

  const totalLeftoverUsable = bins.reduce((s,b)=>s + b.rem, 0);
  return { ok:true, plan:{ results, totalLeftoverUsable, trim, newDisplays } };
}

// Output with NEW-bar group headers (always show any created NEW headers)
function format(plan){
  const out = [];
  out.push("=== WHAT TO USE ===\n");

  // Sort overall: non-weld first, welded last, then by seq
  const sorted = [...plan.results].sort((a,b)=>{
    if (a.welded !== b.welded) return a.welded ? 1 : -1;
    return a.seq - b.seq;
  });

  const stockLines = [];
  const byNew = new Map(); // key: "11900#1" -> lines

  for (const r of sorted){
    if (!r.mainDisplay){
      stockLines.push(r);
    } else {
      if (!byNew.has(r.mainDisplay)) byNew.set(r.mainDisplay, []);
      byNew.get(r.mainDisplay).push(r);
    }
  }

  // STOCK / OFFCUTS section
  if (stockLines.length){
    out.push("STOCK / OFFCUTS");
    for (const r of stockLines){
      if (!r.welded){
        out.push(`${r.need} = ${r.need} (${r.parts[0].fromDisplay})`);
      } else {
        const partsTxt = r.parts.map(p => `${p.cut} (${p.fromDisplay})`).join(" + ");
        out.push(`${r.need} üî• = ${partsTxt}`);
      }
    }
    out.push("");
  }

  // NEW headers: ALWAYS for each created NEW bar, in numeric order
  const newKeys = (plan.newDisplays || []).slice().sort((a,b)=>{
    const na = Number((a.split("#")[1]||"0"));
    const nb = Number((b.split("#")[1]||"0"));
    return na - nb;
  });

  for (const key of newKeys){
    out.push(key);
    const lines = (byNew.get(key) || []).slice();

    // inside each NEW group: non-weld first, welded last, then seq
    lines.sort((a,b)=>{
      if (a.welded !== b.welded) return a.welded ? 1 : -1;
      return a.seq - b.seq;
    });

    if (!lines.length){
      out.push("(no cuts)");
      out.push("");
      continue;
    }

    for (const r of lines){
      if (!r.welded){
        out.push(`${r.need} = ${r.need} (${r.parts[0].fromDisplay})`);
      } else {
        const partsTxt = r.parts.map(p => `${p.cut} (${p.fromDisplay})`).join(" + ");
        out.push(`${r.need} üî• = ${partsTxt}`);
      }
    }
    out.push("");
  }

  out.push(`Leftover saved (usable): ${plan.totalLeftoverUsable} mm`);
  out.push(`Stock trim used: ${plan.trim} mm`);
  return out.join("\n");
}

// UI
const stockLenEl = document.getElementById("stockLen");
const profileEl  = document.getElementById("profile");
const trimEl     = document.getElementById("stockTrim");
const lengthsEl  = document.getElementById("lengths");
const resultEl   = document.getElementById("result");

const stockProfile = document.getElementById("stockProfile");
const stockAdd     = document.getElementById("stockAdd");
const stockView    = document.getElementById("stockView");

document.getElementById("calcBtn").onclick = () => {
  const stockLen = Math.round(Number(stockLenEl.value));
  const profile = profileEl.value.trim();
  const trim = Math.max(0, Math.round(Number(trimEl.value || 0)));
  const needs = parseLengths(lengthsEl.value);

  if (!profile) { resultEl.textContent = "‚ùå Please enter Profile."; return; }
  if (!(stockLen > 0)) { resultEl.textContent = "‚ùå Stock Length must be > 0."; return; }
  if (!needs.length) { resultEl.textContent = "‚ùå Enter at least one required length."; return; }

  const res = makePlan(stockLen, profile, needs, trim);
  if (!res.ok) { resultEl.textContent = "‚ùå " + res.error; return; }
  resultEl.textContent = format(res.plan);
};

document.getElementById("clearBtn").onclick = () => {
  lengthsEl.value = "";
  resultEl.textContent = "‚Äî";
};

document.getElementById("addStock").onclick = () => {
  const p = stockProfile.value.trim();
  const v = Math.round(Number(stockAdd.value));
  if (!p || !(v > 0)) return;
  const a = getStock(p); a.push(v); setStock(p,a);
  stockAdd.value = "";
  refreshStock();
};

document.getElementById("addFull").onclick = () => {
  const p = stockProfile.value.trim();
  const v = Math.round(Number(stockLenEl.value || 11900));
  if (!p || !(v > 0)) return;
  const a = getStock(p); a.push(v); setStock(p,a);
  refreshStock();
};

document.getElementById("clearStock").onclick = () => {
  const p = stockProfile.value.trim();
  if (!p) return;
  setStock(p, []);
  refreshStock();
};

document.querySelectorAll(".tab").forEach(b=>{
  b.onclick = () => {
    document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
    b.classList.add("active");
    document.getElementById("calc").style.display = b.dataset.tab==="calc" ? "" : "none";
    document.getElementById("stock").style.display = b.dataset.tab==="stock" ? "" : "none";
    refreshStock();
  };
});

refreshStock();
</script>

</body>
</html>